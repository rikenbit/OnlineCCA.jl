"""
    oocmcca(;input::AbstractArray=[], outdir::Union{Nothing,AbstractString}=nothing, scale::AbstractArray=[], pseudocount::AbstractArray=[], colmeanlist::AbstractArray="", colvarlist::Union{AbstractString,AbstractArray}="", dim::Number=3, lower::Number=0, upper::Number=1.0f+38, offsetStoch::Number=1f-20, initW::Union{Nothing,AbstractArray}=nothing, perm::Bool=false)
Online CCA solved by Out-of-core CCA.
Input Arguments
---------
- `input` : Julia Binary file generated by `OnlineCCA.csv2bin` function.
- `outdir` : The directory specified the directory you want to save the result.
- `scale` : {log,ftt,raw}-scaling of the value.
- `pseudocount` : The number specified to avoid NaN by log10(0) and used when `Feature_LogMeans.csv` <log10(mean+pseudocount) value of each feature> is generated.
- `colmeanlist` : The mean of each column of matrix. The CSV file is generated by `OnlineCCA.sumr` functions.
- `colvarlist` : The variance of each column of matrix. The CSV file is generated by `OnlineCCA.sumr` functions.
- `dim` : The number of dimension of CCA.
- `lower` : Stopping Criteria (When the relative change of error is below this value, the calculation is terminated)
- `upper` : Stopping Criteria (When the relative change of error is above this value, the calculation is terminated)
- `offsetStoch` : Off set value for avoding overflow when calculating stochastic gradient
- `initW` : The CSV file saving the initial values of eigenvectors.
- `perm` : Whether the data matrix is shuffled at random.
Output Arguments
---------
- `W` : Eigen vectors of covariance matrix (No. columns of the data matrix × dim)
- `λ` : Eigen values (dim × dim)
- `V` : Loading vectors of covariance matrix (No. rows of the data matrix × dim)
- `ExpCorVar` : Explained correlation/variance by the eigenvectors
- `TotalCorVar` : Total correlation/variance of the data matrix
- `Objective` : The summation of object function (e.g. w_i' X_i' X_j w_j)
- `AvgLatentCor` : The mean of correlation efficient of latent variables (e.g. cor(X_i w_i, X_j w_j))
"""
function oocmcca(;input::AbstractArray=[], outdir::Union{Nothing,AbstractString}=nothing, scale::AbstractArray=[], pseudocount::AbstractArray=[], colmeanlist::AbstractArray="", colvarlist::Union{AbstractString,AbstractArray}="", dim::Number=3, lower::Number=0, upper::Number=1.0f+38, offsetStoch::Number=1f-6, initW::Union{Nothing,AbstractArray}=nothing, perm::Bool=false)
    # Initial Setting
    cca = OOCMCCA()
    pseudocount, W, v, D, colmeanlist, colmeanvec, colvarlist, colvarvec, N, M, TotalCorVar, offsetStoch = init(input, pseudocount, dim, colmeanlist, colvarlist, initW, cca, offsetStoch, scale)
    # Perform CCA
    out = oocmcca(input, outdir, scale, pseudocount, colmeanlist, colvarlist, dim, cca, W, v, D, colmeanvec, colvarvec, N, M, TotalCorVar, offsetStoch, perm)
    if outdir isa String
        output(outdir, out, cca)
    end
    return out
end

function oocmcca(input, outdir, scale, pseudocount, colmeanlist, colvarlist, dim, cca, W, v, D, colmeanvec, colvarvec, N, M, TotalCorVar, offsetStoch, perm)
    N, M = nm(input)
    tmpN = zeros(UInt32, 1)
    tmpM = zeros(UInt32, 1)
    l = length(input)
    p = dim + 5
    its = 3
    for i=1:l
        @assert 0 < dim ≤ l ≤ min(N[i], M[i])
    end
    x = Any[]
    normx = Any[]
    Ω = Any[]
    for i=1:l
        push!(x, zeros(UInt32, M[i]))
        push!(normx, zeros(Float32, M[i]))
        push!(Ω, rand(Float32, M[i], p) * offsetStoch)
    end
    Y = Array{Any,2}(undef, l, l)
    for i = 1:l
        for j = 1:l
            Y[i,j] = zeros(Float32, M[i], p)
        end
    end
    stream = Any[]
    #
    # Random Projection
    #
    println("Random Projection : Y_ij = X_i' * X_j * Ω_j")
    progress = Progress(N[1])
    for n = 1:N[1]
        next!(progress)
        if n == 1
            stream = Any[]
            # Stream
            for i=1:l
                push!(stream, ZstdDecompressorStream(open(input[i])))
            end
            # tmpN, tmpN
            for i=1:l
                read!(stream[i], tmpN)
                read!(stream[i], tmpM)
            end
        else
            # x, norm
            for i=1:l
                read!(stream[i], x[i])
                normx[i] = normalizex(x[i], n, stream[i], scale[i], pseudocount[i], colmeanlist[i], colmeanvec[i], colvarlist[i], colvarvec[i])
                if perm
                    normx[i] .= normx[randperm(length(normx[i]))]
                end
            end
            # Random Projection
            for i=1:l
                for j=1:l
                    Y[i,j] .+= normx[i] * (normx[j]'Ω[j])
                end
            end
            # close
            if n == N[1]
                for i=1:l
                    close(stream[i])
                end
            end
        end
    end

    #
    # Renormalize with LU factorization
    #
    F = Array{Any,2}(undef, l, l)
    for i = 1:l
        for j = 1:l
            tmpF = lu!(Y[i,j])
            F[i,j] = Matrix(tmpF.L)
        end
    end

    for s in 1:its
        println("Renormalization : X_i' * X_j * L_ij")
        progress = Progress(N[1])
        for n = 1:N[1]
            next!(progress)
            if n == 1
                stream = Any[]
                # Stream
                for i=1:l
                    push!(stream, ZstdDecompressorStream(open(input[i])))
                end
                # tmpN, tmpN
                for i=1:l
                    read!(stream[i], tmpN)
                    read!(stream[i], tmpM)
                end
            else
                # x, norm
                for i=1:l
                    read!(stream[i], x[i])
                    normx[i] = normalizex(x[i], n, stream[i], scale[i], pseudocount[i], colmeanlist[i], colmeanvec[i], colvarlist[i], colvarvec[i])
                    if perm
                        normx[i] .= normx[randperm(length(normx[i]))]
                    end
                end
                # Renormalize with LU factorization
                for i=1:l
                    for j=1:l
                        Y[i,j] .+= normx[i]*normx[j]'F[j,i]
                    end
                end
                # close
                if n == N[1]
                    for i=1:l
                        close(stream[i])
                    end
                end
            end
        end
        if s < its
            # Renormalize with LU factorization
            for i = 1:l
                for j = 1:l
                    tmpF = lu!(Y[i,j])
                    F[i,j] = Matrix(tmpF.L[:,1:p])
                end
            end
        else
            # Renormalize with QR factorization
            for i = 1:l
                for j = 1:l
                    tmpF = qr!(Y[i,j])
                    F[i,j] = Matrix(tmpF.Q[:,1:p])
                end
            end
        end
    end
    #
    # Small Matrix
    #
    println("Calculation of small matrix : R")
    R = Array{Any,2}(undef, l, l)
    for i = 1:l
        for j = 1:l
            R[i,j] = ones(Float32, p, p)
        end
    end
    progress = Progress(N[1])
    for n = 1:N[1]
        next!(progress)
        if n == 1
            stream = Any[]
            # Stream
            for i=1:l
                push!(stream, ZstdDecompressorStream(open(input[i])))
            end
            # tmpN, tmpN
            for i=1:l
                read!(stream[i], tmpN)
                read!(stream[i], tmpM)
            end
        else
            # x, norm
            for i=1:l
                read!(stream[i], x[i])
                normx[i] = normalizex(x[i], n, stream[i], scale[i], pseudocount[i], colmeanlist[i], colmeanvec[i], colvarlist[i], colvarvec[i])
                if perm
                    normx[i] .= normx[randperm(length(normx[i]))]
                end
            end
            # Small Matrix
            for i=1:l
                for j=1:l
                    if i != j
                        R[i,j] .+= (F[i,j]'normx[i]) * (normx[j]'F[j,i])
                    end
                end
            end
            # close
            if n == N[1]
                for i=1:l
                    close(stream[i])
                end
            end
        end
    end

    # EVD with small matrix
    println("EVD with small matrix : R W = W Λ")
    newR = zeros(Float32, l*p, l*p)
    xstart = 1
    xend = p
    ystart = 1
    yend = p
    for i=1:l
        for j=1:l
            newR[xstart:xend, ystart:yend] = R[i,j]
            ystart = ystart + p
            yend = yend + p
        end
        ystart = 1
        yend = p
        xstart = xstart + p
        xend = xend + p
    end
    smallW = eigvecs(newR)

    # W[i] = M[i] * dim
    wstart = 1
    wend = p
    for i=1:l
        W[i] = F[i,i] * smallW[wstart:wend, 1:dim]
        wstart = wstart + p
        wend = wend + p
    end

    # Return, W, λ, V
    out = WλV(W, input, dim, scale, pseudocount, colmeanlist, colmeanvec, colvarlist, colvarvec, TotalCorVar)
    return (out[1], out[2], out[3], out[4], out[5], out[6], out[7])
end
